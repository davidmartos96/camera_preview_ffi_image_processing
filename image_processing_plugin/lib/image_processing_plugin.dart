import "dart:developer";
import "dart:ffi" as ffi;
import "dart:io" show Platform; // For Platform.isX
import "dart:typed_data";

import "package:image_processing_plugin/allocation.dart";

final ffi.DynamicLibrary ffiBinding = Platform.isAndroid
    ? ffi.DynamicLibrary.open("libffitest.so") // Open the shared library generated by cmake.
    : ffi.DynamicLibrary.process(); // Use the wrapper included in the runner project.

final double Function(ffi.Pointer<ffi.Uint8>, int, int, int) ffiProcessImage = ffiBinding
    .lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Uint8>, ffi.Int32, ffi.Int32, ffi.Int32)>>("ffiProcessImage")
    .asFunction();

class ImageProcessingPlugin {
  double processImage(Uint8List data, int width, int height, int scanLine) {
    try {
      int time = DateTime.now().millisecondsSinceEpoch;
      // Based on the code found here https://github.com/renancaraujo/bitmap/blob/master/lib/ffi.dart in the execute function
      Timeline.startSync("image_processing_plugin: preparing data for the ffi");
      final ffi.Pointer<ffi.Uint8> frameData = allocate<ffi.Uint8>(count: data.length); // Allocate a pointer large enough, create a list that can hold our data, and set it.
      final pointerList = frameData.asTypedList(data.length);
      pointerList.setAll(0, data);
      Timeline.finishSync();
      print("ZZZZZ data preparation: ${DateTime.now().millisecondsSinceEpoch - time}ms");

      time = DateTime.now().millisecondsSinceEpoch;
      Timeline.startSync("image_processing_plugin: processing image data in the ffi");
      double result = ffiProcessImage(frameData, width, height, scanLine);
      Timeline.finishSync();
      int timeTaken = DateTime.now().millisecondsSinceEpoch - time;
      print("ZZZZZ ffi call: ${timeTaken}ms");

      Timeline.startSync("image_processing_plugin: freeing prepared data");
      free(frameData);
      Timeline.finishSync();
      return result;
    } on Exception catch(e) {
      print("ZZZZZ processImage: exception: ${e.toString()}");
      return -1; // TODO Return a meaningful error code here.
    }
  }

// ZZZZZ Platform Channels are not an option for us due to performance reasons.
//  static const MethodChannel _channel =
//      const MethodChannel('channel_name');
//
//  static Future<String> get platformVersion async {
//    final String version = await _channel.invokeMethod('getPlatformVersion');
//    return version;
//  }

}

