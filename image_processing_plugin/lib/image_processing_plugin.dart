import "dart:developer";
import "dart:ffi" as ffi;
import "dart:io" show Platform; // For Platform.isX

final ffi.DynamicLibrary ffiBinding = Platform.isAndroid
    ? ffi.DynamicLibrary.open("libffitest.so") // Open the shared library generated by cmake.
    : ffi.DynamicLibrary.process(); // Use the wrapper included in the runner project.

final double Function(ffi.Pointer<ffi.Uint8>, int, int, int) ffiProcessImage = ffiBinding
    .lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Uint8>, ffi.Int32, ffi.Int32, ffi.Int32)>>("ffiProcessImage")
    .asFunction();

class ImageProcessingPlugin {
  double processImage(ffi.Pointer<ffi.Uint8> frameData, int width, int height, int scanLine) {
    try {
      int time = DateTime.now().millisecondsSinceEpoch;
      Timeline.startSync("image_processing_plugin: processing image data in the ffi");
      double result = ffiProcessImage(frameData, width, height, scanLine);
      Timeline.finishSync();
      int timeTaken = DateTime.now().millisecondsSinceEpoch - time;
      print("ZZZZZ processImage: ffi call: ${timeTaken}ms");

      return result;
    } on Exception catch(e) {
      print("ZZZZZ processImage: exception: ${e.toString()}");
      return -1; // TODO Return a meaningful error code here.
    }
  }

// ZZZZZ Platform Channels are not an option for us due to performance reasons.
//  static const MethodChannel _channel =
//      const MethodChannel('channel_name');
//
//  static Future<String> get platformVersion async {
//    final String version = await _channel.invokeMethod('getPlatformVersion');
//    return version;
//  }

}

